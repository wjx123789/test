# 525日 #
## RTMP（实时消息传输协议）（路由选择表维护协议） ##
rpmp是Real time message protocol(实时消息传输协议)的首字母缩写。该协议基于tcp，是一个协议族，包括rtmp基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据同行协议，主要用在falsh/air平台和支持rtmp协议的流媒体/交互服务器之间进行音视频和数据通讯。支持rtmp协议的流媒体/交互服务器之间进行音视频和数据通信。

rtmp又是routing table maintenance protocol（路由选择表维护协议）的缩写。在apple talk协议组中，路由选择表维护协议（RTMP,routing table maintenance protocol）是一种传输层协议，他在apple talk路由器中简历并维护路由选择表。
rtmp基于路由选择信息协议（rip）。正如rip一样，rtmp使用条数作为路由计量标准。一个数据包从源网络发送到目标网络，必须通过路由器或其他中间介质节点数目的计算结果即为跳数。

- rtmp工作在tcp上，默认端口1935.
- rtmpe在rtmp基础上增加了加密功能
- rtmp封装在http请求之上，可穿透防火墙。
- rtmps类似rtmpt，增加了tls/ssl的安全功能


握手请求、应答
Client → Server :向服务器发出握手请求.这不属于协议包一部分,该握手请求第一个字节为(0×03),其后跟着1536个字节.尽管看上去这部分的内容对于RTMP协议来说并不是至关重要的,但也不可随意对待.

Server → Client :服务器向客户端回应握手请求.这部分的数据仍然不属于RTMP协议的部分.该回应的起始字节仍然为(0x03),但是后边跟着两个长度为1536个字节(一共为3072字节 )的包块.第一个1536块看上去似乎可以是任意内容,甚至好像可以是Null都没有关系.第二个1536的代码块,是上一步客户端向服务器端发送的握手请求的内容.

Client→Server:把上一步服务器向客户端回应的第二块1536个字节的数据块.
至此客户端与服务器端的握手结束,下面将发送RTMP协议的包内容.

Client → Server :向服务器发送连接包.

Server → Client :服务器回应.

## mysql分表的几种方式 ##
1. mysql集群
	它并不是分表，但起到了和分表相同的作用。集群可分担数据库的操作次数，将任务分担到多台数据库上。集群可以读写分离，减少读写压力。从而提升数据库性能。
2. 预先估计会出现大数据量并且访问频繁的表，将其分为若干个表
	可以设计每张表容纳的数据量是N条，那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当<N条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作）。

	
	mysql> insert into tb_member1(id,name,sex) select id,name,sex from member where id%2=0;
	
	mysql> insert into tb_member2(id,name,sex) select id,name,sex from member where id%2=1;
	
3. 利用merge存储引擎来实现分表
	如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了，用merge存储引擎来实现分表, 这种方法比较适合。

	merge分表，分为主表和子表，主表类似于一个壳子，逻辑上封装了子表，实际上数据都是存储在子表中的。

	我们可以通过主表插入和查询数据，如果清楚分表规律，也可以直接操作子表。



## 分区 ##
	https://blog.csdn.net/kangshuo2471781030/article/details/79316737

	查看是否支持分区的sql语句(5.6之前)：show variables like '%partition%'
	5.6之后：show plugines

分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，分区后，表还是一张表，但数据散列到多个位置了。app读写的时候操作的还是表名字，db自动取组织分区的数据。

- 水平分区：这种i形式分区是对表的行进行分区，所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。
	举个简单例子：一个包含十年发票记录的表可以被分区为10个不同的分区，每个分区包含的是其中一年的记录。
- 垂直分区：这种分区一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定到分区，每个分区都包含了其中的列所对应的行。
	举个简单的例子：一个包含了大text和blob列的表，这些text和blob列又不经常被访问，这时候就要把这些不经常使用的text和blob划分到另一个分区，在保证他们数据相关性的同时还能提高访问速度。

## mysql分区的类型 ##
1. range分区：基于属于一个给定连续区间的列值，把多行分配给分区。这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。以下是实例。
2. list分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。
3. hash分区：这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。
4. key分区：mysql-5.5开始支持COLUMNS分区，可视为RANGE和LIST分区的进化，COLUMNS分区可以直接使用非整形数据进行分区。
	
		支持以下数据类型：
			- 所有整形：如int, samllint,tinyint,bigint。float和decimal则不支持.
			- 日期类型，如date和datetime。其余日期类型不支持。
			- 字符串类型，如char、charhar、binary和varbinary。blob和text类型不支持。columns可以使用多个列进行分区。

## mysql分表和分区有什么区别 ##
1. 实现方式上
	- mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。
	-  分区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了

2.数据处理上：
	
-  	分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。
-  	分区呢，不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表呢，还是一张表，数据处理还是由自己来完成。

3.提高性能上

- 分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。
- mysql提出了分区的概念，主要是想突破磁盘I/O瓶颈，想提高磁盘的读写能力，来增加mysql性能。
在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。

4：实现难易度上

- 分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式跟分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。
- 分区实现是比较简单的，建立分区表，根建平常的表没什么区别，并且对代码端来说是透明的。
