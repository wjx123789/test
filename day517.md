## day517 ##
1：上午
	
- 分析算法和数据结构
- 算法排序分为比较类排序和非比较类排序
- 比较类有一下几点：冒泡、快速、简单插入、希尔、简单选择、堆、二路归并、多路归并
- 非比较排序分为一下几点：计数、桶、基数

2：下午

- 秒杀：
- 第一步： 用户首先进入商品秒杀页面，当到达秒杀时间时前端的下单按钮才能点亮；
- 第二步： 点击以后并不是所有用户都能到达下单页面，1W+用户同时下单可能就只有20个用户才能进入下单页面，其他的用户直接到达秒杀结束页面，此时步骤可以使用Redis的单线程特性来统计和控制下单人数；
- 第三步： 成功进入填写订单页面的用户填写完订单以后再次提交订单，虽然此时并发请求数量最多只有20，但是我们还是需要使用Redis的单线程特性来统计和控制能真正下单的人数，此时能秒杀成功的可能只有最早提交订单的2个用户，剩下的18位用户直接返回秒杀失败页面；
- 第四步： 此时将成功的两位用户的下单任务加入消息队列RabbitMQ，让下单页面负责真正的创建订单，商品库存的减少以及后续其他相关操作；
- 第五步： 返回给两位用户的只要一个秒杀成功页面和支付页面即可。
- 对于超高并发的秒杀，我们可以做负载均衡，秒杀页面可以静态化的缓存在CDN服务器中，这样用户反复刷新页面并不会请求服务器，此外我们的Redis就需要集群了。


3：晚上

- token和session的区别是什么？
- token和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；
- session服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；
- 其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。
- 方案 A ：我发给你一张身份证，但只是一张写着身份证号码的纸片。你每次来办事，我去后台查一下你的 id 是不是有效。
- 方案 B ：我发给你一张加密的身份证，以后你只要出示这张卡片，我就知道你一定是自己人。

### 单表遇到过最大数据量是多少？ ###

- 在mysql中，每个数据库最多可创建20亿个表，一个表允许定义1024列，每行的最大长度为8092字节（不包括文本和图像类型的长度）。当表中定义有varchar、nvarchar或varbinary类型列时，如果向表中插入的数据行超过8092字节时将导致Transact-SQL语句失败，并产生错误信息。SQL Server对每个表中行的数量没有直接限制，但它受数据库存储空间的限制。每个数据库的最大空间1048516TB，所以一个表可用的最大空间为1048516TB减去数据库类系统表和其它数据库对象所占用的空间。

### 未过期的token还是可以用（使token失效）? ###

- 解决方案1：当用户第一次登录成功后将token存到数据库，每次都对比传过来的token和该用户在数据库的token是否相同。
- 解决方案2(推荐回答方式)：1)将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则（这不就和 session 一样了么？）。2)维护一个 token 黑名单，失效则加入黑名单中。3)在 JWT 中增加一个版本号字段，失效则改变该版本号。4)在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。